!function(t){var e={};function r(i){if(e[i])return e[i].exports;var n=e[i]={i:i,l:!1,exports:{}};return t[i].call(n.exports,n,n.exports,r),n.l=!0,n.exports}r.m=t,r.c=e,r.d=function(t,e,i){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(r.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)r.d(i,n,function(e){return t[e]}.bind(null,n));return i},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=0)}([function(t,e,r){"use strict";function i(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}r.r(e);class n{constructor(t,e,r){i(this,"addition",t=>{if(!t instanceof n)throw new Error("param vector was not Vector");return new n(this.x+t.x,this.y+t.y,this.z+t.z)}),i(this,"subtraction",t=>{if(!t instanceof n)throw new Error("param vector was not Vector");return new n(this.x-t.x,this.y-t.y,this.z-t.z)}),i(this,"multiplication",t=>{if("number"!=typeof t)throw new Error("param num was not numeric");return new n(this.x*t,this.y*t,this.z*t)}),i(this,"division",t=>{if("number"!=typeof t)throw new Error("param num was not numeric");return new n(this.x/t,this.y/t,this.z/t)}),i(this,"dot",t=>{if(!t instanceof n)throw new Error("param v was not Vector");return this.x*t.x+this.y*t.y+this.z+t.z}),i(this,"length",()=>Math.sqrt(this.squareLength())),i(this,"squareLength",()=>this.x*this.x+this.y*this.y+(this.z+this.z)),i(this,"norm",()=>{var t=this.length();return 0==t?new n:new n(this.x/t,this.y/t,this.z/t)}),i(this,"equals",t=>{if(!t instanceof n)throw new Error("param v was not Vector");return this.x==t.x&&this.y==t.y&&this.z==t.z}),i(this,"toString",()=>"("+this.x+", "+this.y+", "+this.z+")"),"number"!=typeof t&&(t=0),"number"!=typeof e&&(e=0),"number"!=typeof r&&(r=0),this.x=t,this.y=e,this.z=r}}var s=n;function a(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var o=class{constructor(){a(this,"clear",()=>{this.arrVector.clear()}),a(this,"push_back",t=>{if(!t instanceof Vector)throw new Error("param v was not Vector type");this.arrVector.push(t)}),a(this,"get",t=>{if("number"==typeof t&&this.arrVector.length>t)return this.arrVector[t]}),a(this,"size",()=>this.arrVector.length),a(this,"reverse",()=>{this.arrVector.reverse()}),a(this,"isEmpty",()=>0===this.arrVector.length),a(this,"insert",(t,e)=>{if(!e instanceof Vector)throw new Error("param vector was not Vector type");this.arrVector.splice(t,0,e)}),this.arrVector=new Array,this.clear=this.clear.bind(this)}};function h(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}class u{constructor(t,e,r){h(this,"getStart",()=>this.start),h(this,"getEnd",()=>this.end),h(this,"length",()=>{var t=this.end.x-this.start.x,e=this.end.y-this.start.y;return Math.sqrt(t*t+e*e)}),h(this,"squareLength",()=>{var t=this.end.x-this.start.x,e=this.end.y-this.start.y;return t*t+e*e}),h(this,"reverse",()=>u.initFromVector(this.end,this.start)),h(this,"getPointAlong",t=>{var e=this.end.subtraction(this.start).norm().multiplication(t);return this.start.addition(e)}),h(this,"getDistance",t=>{if(void 0!==t&&t instanceof s){var e=this.A*t.x+this.B*t.y+this.C,r=Math.sqrt(this.A*this.A+this.B*this.B);return Math.abs(e/r)}}),h(this,"getLineNearestPoint",t=>{if(void 0!==t&&t instanceof s){var e=new s(this.B,-this.A),r=t.subtraction(this.start).dot(e)/e.squareLength();return this.start.addition(e.multiplication(r))}}),h(this,"getSegmentNearestPoint",t=>{if(void 0===t)throw new Error("param point was undefined");if(!t instanceof s)throw new Error("param point was not Vector Type");var e=new s(this.B,-this.A,0),r=t.subtraction(this.start).dot(e)/e.squareLength();return r<0?this.start:r>1?this.end:this.start.addition(e.multiplication(r))}),h(this,"pointSide",t=>{var e=this.A.multiplication(t.x-this.start.x).addition(B.multiplication(t.x-this.start.y));return e>0?1:e<0?-1:0}),h(this,"crossLineSegment",t=>{var e=u.det(this.A,this.B,t.A,t.B),r=new s;return 0==e?0:(r.x=-u.det(this.C,this.B,t.C,t.B)/e,r.y=-u.det(this.A,this.C,t.A,t.C)/e,{result:r,value:u.inside(r.x,u.minimum(t.start.x,t.end.x),u.maximum(t.start.x,t.end.x))&&u.inside(r.y,u.minimum(t.start.y,t.end.y),u.maximum(t.start.y,t.end.y))})}),h(this,"crossSegmentSegment",t=>{var e=u.det(this.A,this.B,t.A,t.B),r=new s;return 0==e?0:(r.x=-u.det(this.C,this.B,t.C,t.B)/e,r.y=-u.det(this.A,this.C,t.A,t.C)/e,{result:r,value:u.inside(r.x,u.minimum(this.start.x,this.end.x),u.maximum(this.start.x,this.end.x))&&u.inside(r.y,u.minimum(this.start.y,this.end.y),u.maximum(this.start.y,this.end.y))&&u.inside(r.x,u.minimum(t.start.x,t.end.x),u.maximum(t.start.x,t.end.x))&&u.inside(r.y,u.minimum(t.start.y,t.end.y),u.maximum(t.start.y,t.end.y))})}),h(this,"crossLineLine",t=>{var e=u.det(this.A,this.B,t.A,t.B),r=new s;return 0==e?0:(r.x=-u.det(this.C,this.B,t.C,t.B)/e,r.y=-u.det(this.A,this.C,t.A,t.C)/e,{result:r,value:1})}),h(this,"getBisector",(t,e)=>{var r=Math.sqrt(t.A*t.A+t.B*t.B),i=Math.sqrt(e.A*e.A+e.B*e.B),n=t.A/r-e.A/i,s=t.B/r-e.B/i,a=t.C/r-e.C/i;return{result:new u(n,s,a),l1:t,l2:e}}),h(this,"getTanAngle",(t,e)=>(t.A*e.B-e.A*t.B)/(t.A*e.A+t.B*e.B)),h(this,"directedLine",(t,e)=>{if(!t instanceof s)throw new Error("param p was not Vector Type");if(!e instanceof s)throw new Error("param d was not Vector Type");return new u(t,t.addition(e))}),h(this,"toString",()=>"["+this.A+", "+this.B+", "+this.C+"]-{"+this.getStart()+", "+this.getEnd()+"}"),this.A=null,this.B=null,this.C=null,this.start=null,this.end=null,"number"==typeof t&&"number"==typeof e&&"number"==typeof r?this.initFromNumbers(t,e,r):t instanceof s&&e instanceof s&&this.initFromVector(t,e)}}h(u,"initFromVector",(t,e)=>{if(!t instanceof s)throw new Error("param start was not Vector Type");if(!e instanceof s)throw new Error("param end was not Vector Type");u.A=t.y-e.y,u.B=e.x-t.x,u.C=t.x*e.y-e.x*t.y,u.start=t,u.end=e}),h(u,"initFromNumbers",(t,e,r)=>{"number"==typeof t&&"number"==typeof e&&"number"==typeof r&&(u.start=new s,u.end=new s,Math.abs(t)<=1e-6&&Math.abs(e)>=1e-6?(u.start.x=-1e3,u.start.y=-r/e,u.end.x=1e3,u.end.y=u.start.y):Math.abs(e)<=1e-6&&Math.abs(t)>=1e-6?(u.start.x=-r/t,u.start.y=-1e3,u.end.x=u.start.x,u.end.y=1e3):(u.start.x=-1e3,u.start.y=-(t*u.start.x+r)/e,u.end.x=1e3,u.end.y=-(t*u.end.x+r)/e)),u.A=t,u.B=e,u.C=r}),h(u,"inside",(t,e,r)=>e<=t+1e-6&&t<=r+1e-6),h(u,"det",(t,e,r,i)=>t*i-e*r),h(u,"maximum",(t,e)=>t<e?e:t),h(u,"minimum",(t,e)=>t>e?e:t);var l=u;function p(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}const c=1e-6;class g{constructor(t){if(p(this,"poly",null),p(this,"countSquare",()=>{var t=this.countSquare_signed();if("number"==typeof t)return t<0?-1*t:t}),p(this,"countSquare_signed",()=>{var t=this.poly.size();if(t<3)return 0;for(var e=0,r=0;r<t;r++)e+=0==r?this.poly.get(r).x*(this.poly.get(t-1).y-this.poly.get(r+1).y):r==t-1?this.poly.get(r).x*(this.poly.get(r-1).y-this.poly.get(0).y):this.poly.get(r).x*(this.poly.get(r-1).y-this.poly.get(r+1).y);return e/2}),p(this,"split",(t,e)=>{if("number"!=typeof t)throw new Error("param square was not defined");var r=Math.round(this.poly.size()),i=this.poly;this.isClockwise()||i.arrVector.reverse();var n=new g,s=new g;if(this.countSquare()-t<=c)return{value:0,poly1:n=this,poly2:s,cutLine:e};for(var a=0,o=Number.MAX_VALUE,h=0;h<r-1;h++)for(var u=h+1;u<r;u++){var p=new g,y=new g,f=g.createSubPoly(i,h,u,p,y);p=f.poly1,y=f.poly2;var d=new l(i.get(h),i.get(h+1)),w=new l(i.get(u),i.get(u+1<r?u+1:0)),m=new l,b=g.getCut(d,w,t,p,y,m);if(m=b.cut,b.value){var v=m.squareLength();v<o&&g.isSegmentInsidePoly(i,m,h,u)&&(o=v,n=p,s=y,e=m,a=1)}}return a?(n.push_back(e.getStart()),n.push_back(e.getEnd()),s.push_back(e.getEnd()),s.push_back(e.getStart()),{value:1,poly1:n,poly2:s,cutLine:e}):{value:0,poly1:n=new g(i),poly2:s,cutLine:e}}),p(this,"findDistance",t=>{if(void 0===t)throw new Error("param point was undefined");if(!t instanceof s)throw new Error("param point was not Vector Type");for(var e=Number.MAX_VALUE,r=0,i=Math.round(this.poly.size()-1);r<i;r++){(n=new l).initFromVector(this.poly.get(r),this.poly.get(r+1)),(a=n.getSegmentNearestPoint(t).subtraction(t).length())<e&&(e=a)}var n,a;return(n=new l).initFromVector(this.poly.get(this.poly.size()-1),this.poly.get(0)),(a=n.getSegmentNearestPoint(t).subtraction(t).length())<e&&(e=a),e}),p(this,"findNearestPoint",t=>{if(void 0===t)throw new Error("param point was undefined");if(!t instanceof s)throw new Error("param point was not Vector Type");for(var e=null,r=Number.MAX_VALUE,i=0,n=Math.round(this.poly.size()-1);i<n;i++){(a=new l).initFromVector(this.poly.get(i),this.poly.get(i+1)),(h=(o=a.getSegmentNearestPoint(t)).subtraction(t).length())<r&&(r=h,e=o)}var a,o,h;return(a=new l).initFromVector(this.poly.get(this.poly.size()-1),this.poly.get(0)),(h=(o=a.getSegmentNearestPoint(t)).subtraction(t).length())<r&&(r=h,e=o),e}),p(this,"countCenter",()=>g.polygonCentroid(this.poly)),p(this,"splitNearestEdge",t=>{if(void 0===t)throw new Error("param point was undefined");if(!t instanceof s)throw new Error("param point was not Vector Type");for(var e,r=-1,i=Number.MAX_VALUE,n=0,a=this.poly.size()-1;n<a;n++){(h=(o=new l(this.poly.get(n),this.poly.get(n+1)).getSegmentNearestPoint(t)).subtraction(t).length())<i&&(i=h,r=n,e=o)}var o,h;(h=(o=new l(this.poly.get(this.poly.size()-1),this.poly.get(0)).getSegmentNearestPoint(t)).subtraction(t).length())<i&&(i=h,r=this.poly.size()-1,e=o),-1!=r&&this.poly.insert(r+1,e)}),p(this,"isPointInside",t=>{if(void 0===t)throw new Error("param point was undefined");if(!t instanceof s)throw new Error("param point was not Vector Type");return g.isPointInsidePoly(this.poly,t)}),p(this,"isClockwise",()=>{for(var t=0,e=Math.round(this.poly.size()-1),r=0;r<e;r++)t+=(this.poly.get(r+1).x-this.poly.get(r).x)*(this.poly.get(r+1).y+this.poly.get(r).y);return(t+=(this.poly.get(0).x-this.poly.get(e).x)*(this.poly.get(0).y+this.poly.get(e).y))<=0}),p(this,"getVectors",()=>this.poly),p(this,"push_back",t=>{void 0!==t&&t instanceof s&&this.poly.push_back(t)}),p(this,"empty",()=>this.poly.empty()),p(this,"get",t=>{if("number"!=typeof t)throw new Error("param idx was not number type");if(this.poly.size()<t)throw new Error("param idx was bigger then Vectors size");return this.poly.get(t)}),p(this,"setPolygon",t=>{if(t instanceof g)return this.poly=t.poly,this}),p(this,"clear",()=>{this.poly.clear()}),p(this,"size",()=>this.poly.size()),p(this,"findCutLine",(t,e,r)=>{if(t>e.totalSquare)return{value:!1};if(!e.leftTriangle.empty()&&t<e.leftTriangleSquare){var i=t/e.leftTriangleSquare,n=e.leftTriangle.get(1).addition(e.leftTriangle.get(2).subtraction(e.leftTriangle.get(1)).multiplication(i));if(e.p1_exist)return r=new l(n,e.leftTriangle.get(0)),{value:!0,res:e,cutLine:r};if(e.p4_exist)return r=new l(e.leftTriangle.get(0),n),{value:!0,res:e,cutLine:r}}else{if(e.leftTriangleSquare<t&&t<e.leftTriangleSquare+e.trapezoidSquare){var s=new l(e.trapezoid.get(0),e.trapezoid.get(3)),a=l.getTanAngle(s,e.bisector),o=t-e.leftTriangleSquare;if(Math.abs(a)>c){var h=new l(e.trapezoid.get(0),e.trapezoid.get(1)).length(),u=new l(e.trapezoid.get(2),e.trapezoid.get(3)).length(),p=2*e.trapezoidSquare/(h+u),g=h*h-4*a*o;i=-(-h+Math.sqrt(g))/(2*a)/p}else i=o/e.trapezoidSquare;n=e.trapezoid.get(0).addition(e.trapezoid.get(3).subtraction(e.trapezoid.get(0)).multiplication(i));var y=e.trapezoid.get(1).addition(e.trapezoid.get(2).subtraction(e.trapezoid.get(1)).multiplication(i));return{value:!0,res:e,cutLine:r=new l(n,y)}}if(!e.rightTriangle.empty()&&t>e.leftTriangleSquare+e.trapezoidSquare){i=(o=t-e.leftTriangleSquare-e.trapezoidSquare)/e.rightTriangleSquare,n=e.rightTriangle.get(2).addition(e.rightTriangle.get(1).subtraction(e.rightTriangle.get(2)).multiplication(i));if(e.p3_exist)return r=new l(e.rightTriangle.get(0),n),{value:!0,res:e,cutLine:r};if(e.p2_exist)return r=new l(n,e.rightTriangle.get(0)),{value:!0,res:e,cutLine:r}}}return{value:!1,res:e,cutLine:r}}),void 0===t)t=new o;else if(!t instanceof o)throw new Error("param v was not Vector Type");this.poly=t}}p(g,"createPolygons",(t,e,r)=>{if(!t instanceof l)throw new Error("param l1 was not Line type");if(!e instanceof l)throw new Error("param l2 was not Line type");if(!r instanceof Polygons)throw new Error("param res was not Polygons type");r.bisector=l.getBisector(t,e).result;var i=t.getStart(),n=t.getEnd(),a=e.getStart(),o=e.getEnd();if(r.p1_exist=!1,r.p4_exist=!1,i!=o){var h=new l(i,r.bisector.getLineNearestPoint(i)),u=new s,p=h.crossLineSegment(e,u);u=p.result,r.p1_exist=p.value&&u!=o,r.p1_exist?(r.leftTriangle.push_back(i),r.leftTriangle.push_back(o),r.leftTriangle.push_back(u),r.trapezoid.push_back(u)):r.trapezoid.push_back(o);var c=new l(o,r.bisector.getLineNearestPoint(o)),g=new s,y=c.crossLineSegment(t,g);g=y.result,r.p4_exist=y.value&&g!=i,r.p4_exist?(r.leftTriangle.push_back(o),r.leftTriangle.push_back(i),r.leftTriangle.push_back(g),r.trapezoid.push_back(g)):r.trapezoid.push_back(i)}else r.trapezoid.push_back(o),r.trapezoid.push_back(i);if(r.p2_exist=!1,r.p3_exist=!1,n!=a){var f=new l(a,r.bisector.getLineNearestPoint(a)),d=new s,w=f.crossLineSegment(t,d);d=w.result,r.p3_exist=w.value&&d!=n,r.p3_exist?(r.rightTriangle.push_back(a),r.rightTriangle.push_back(n),r.rightTriangle.push_back(d),r.trapezoid.push_back(d)):r.trapezoid.push_back(n);var m=new l(n,r.bisector.getLineNearestPoint(n)),b=new s,v=m.crossLineSegment(e,b);b=v.result,r.p2_exist=v.value&&b!=a,r.p2_exist?(r.rightTriangle.push_back(n),r.rightTriangle.push_back(a),r.rightTriangle.push_back(b),r.trapezoid.push_back(b)):r.trapezoid.push_back(a)}else r.trapezoid.push_back(n),r.trapezoid.push_back(a);return r.leftTriangleSquare=r.leftTriangle.countSquare(),r.trapezoidSquare=r.trapezoid.countSquare(),r.rightTriangleSquare=r.rightTriangle.countSquare(),r.totalSquare=r.leftTriangleSquare+r.trapezoidSquare+r.rightTriangleSquare,r}),p(g,"getCut",(t,e,r,i,n,s)=>{if(!t instanceof l)throw new Error("param l1 was not Line type");if(!e instanceof l)throw new Error("param l2 was not Line type");if(!i instanceof g)throw new Error("param poly1 was not Polygon type");if(!n instanceof g)throw new Error("param poly2 was not Polygon type");if("number"!=typeof r)throw new Error("param s was not number type");var a=r+n.countSquare_signed(),o=r+i.countSquare_signed();if(a>0){var h=new Polygons;h=g.createPolygons(t,e,h);s=(u=g.findCutLine(a,h,s)).cutLine;if(u.value)return{value:!0,cut:s}}else if(o>0){h=new Polygons;h=g.createPolygons(e,t,h);var u;s=(u=g.findCutLine(o,h,s)).cutLine;if(u.value)return{value:!0,cut:s=s.reverse()}}return{value:!1,cut:s}}),p(g,"createSubPoly",(t,e,r,i,n)=>{if(!t instanceof o)throw new Error("param poly was not Vectors Type");i=new g,n=new g;for(var s=r-e,a=1;a<=s;a++)i.push_back(t.get(a+e));var h=t.size(),u=h-s;for(a=1;a<=u;a++)n.push_back(t.get((a+r)%h));return{poly1:i,poly2:n}}),p(g,"isPointInsidePoly",(t,e)=>{for(var r=Math.round(t.size()-1),i=l.directedLine(e,new s(0,1e100)),n=0,a=0;a<r;a++){var o=new l(t.get(a),t.get(a+1));n+=i.crossSegmentSegment(o).value}o=new l(t.get(r),t.get(0));return(n+=i.crossSegmentSegment(o).value)%2!=0}),p(g,"isSegmentInsidePoly",(t,e,r,i)=>{for(var n=t.size(),a=0;a<n;a++)if(a!=r&&a!=i){var o=t.get(a),h=t.get(a+1<n?a+1:0),u=new s,p=new l(o,h).crossSegmentSegment(e,u);if(u=p.result,p.value&&o.subtraction(u).squareLength()>c&&h.subtraction(u).squareLength()>c)return 0}return g.isPointInsidePoly(t,e.getPointAlong(.5))}),p(g,"polygonCentroid",t=>{for(var e=t.size(),r=new s(0,0,0),i=0;i<e;i++)r=r.addition(t.get(i));return r=r.division(e)})}]);
//# sourceMappingURL=bundle.js.map